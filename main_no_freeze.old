package main

import (
	"math/rand"
	"runtime"
	"syscall"
	"time"
	"unsafe"

	"github.com/jibaru/gominiwin/windows"
	mylibrary "github.com/jibaru/gominiwin/windows/primitives"
)

// Constantes del juego
const (
	CELL_SIZE     = 20
	GRID_WIDTH    = 30 * 2
	GRID_HEIGHT   = 20 * 2
	WINDOW_WIDTH  = CELL_SIZE * GRID_WIDTH
	WINDOW_HEIGHT = CELL_SIZE * GRID_HEIGHT
	SPEED         = 60 // Velocidad del juego (en ms)
)

// Direcciones de movimiento
type Direction int

const (
	UP Direction = iota
	DOWN
	LEFT
	RIGHT
)

// Punto (coordenadas de una celda)
type Point struct {
	X, Y int
}

// Variables globales
var (
	snake    []Point
	food     Point
	dir      Direction = RIGHT
	gameOver bool
	painter  *windows.Painter
	updating bool
)

func init() {
	// This is needed to arrange that main() runs on main thread.
	// See documentation for functions that are only allowed to be called from the main thread.
	runtime.LockOSThread()
}

// Generar comida en una posición aleatoria
func GenerateFood() {
	food.X = rand.Intn(GRID_WIDTH)
	food.Y = rand.Intn(GRID_HEIGHT)
}

// Verificar colisiones
func CheckCollision(head Point) bool {
	// Colisión con paredes
	if head.X < 0 || head.X >= GRID_WIDTH || head.Y < 0 || head.Y >= GRID_HEIGHT {
		return true
	}
	// Colisión con el cuerpo
	for _, segment := range snake[1:] {
		if segment.X == head.X && segment.Y == head.Y {
			return true
		}
	}
	return false
}

// Mover la serpiente
func MoveSnake() {
	if gameOver {
		return
	}

	// Nueva posición de la cabeza
	head := snake[0]
	switch dir {
	case UP:
		head.Y--
	case DOWN:
		head.Y++
	case LEFT:
		head.X--
	case RIGHT:
		head.X++
	}

	// Verificar colisión
	if CheckCollision(head) {
		gameOver = true
		return
	}

	// Agregar nueva cabeza
	snake = append([]Point{head}, snake...)

	// Comer comida o mover cola
	if head.X == food.X && head.Y == food.Y {
		GenerateFood()
	} else {
		snake = snake[:len(snake)-1]
	}
}

// Dibujar el juego
func DrawGame() {
	// Limpiar pantalla
	painter.RectangleFilled(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, windows.NEGRO)

	// Dibujar comida
	painter.RectangleFilled(
		food.X*CELL_SIZE, food.Y*CELL_SIZE,
		(food.X+1)*CELL_SIZE, (food.Y+1)*CELL_SIZE,
		windows.VERDE,
	)

	// Dibujar serpiente
	for _, segment := range snake {
		painter.RectangleFilled(
			segment.X*CELL_SIZE, segment.Y*CELL_SIZE,
			(segment.X+1)*CELL_SIZE, (segment.Y+1)*CELL_SIZE,
			windows.AZUL,
		)
	}

	// Dibujar mensaje de Game Over
	if gameOver {
		painter.Text(WINDOW_WIDTH/2-50, WINDOW_HEIGHT/2, "GAME OVER", windows.BLANCO)
	}
}

// Procesador de eventos de ventana
func WndProc(hwnd mylibrary.HWND, msg uint32, wparam, lparam uintptr) uintptr {
	switch msg {
	case mylibrary.WM_CREATE:
		// Inicializar el juego
		snake = []Point{{5, 5}, {4, 5}, {3, 5}}
		GenerateFood()
		mylibrary.SetTimer(hwnd, 1, SPEED, mylibrary.NULL)

	case mylibrary.WM_TIMER:
		updating = true
		MoveSnake()
		mylibrary.InvalidateRect(hwnd, nil, false)
		updating = false
	case mylibrary.WM_KEYDOWN:
		switch wparam {
		case mylibrary.VK_UP:
			if dir != DOWN {
				dir = UP
			}
		case mylibrary.VK_DOWN:
			if dir != UP {
				dir = DOWN
			}
		case mylibrary.VK_LEFT:
			if dir != RIGHT {
				dir = LEFT
			}
		case mylibrary.VK_RIGHT:
			if dir != LEFT {
				dir = RIGHT
			}
		}

	case mylibrary.WM_PAINT:
		hdc, ps, _ := mylibrary.BeginPaint(hwnd)
		painter = windows.NewPainter(WINDOW_WIDTH, WINDOW_HEIGHT, hdc)
		DrawGame()
		mylibrary.EndPaint(hwnd, ps)

	case mylibrary.WM_DESTROY:
		//mylibrary.KillTimer(hwnd, 1)
		mylibrary.PostQuitMessage(0)

	default:
		return mylibrary.DefWindowProc(hwnd, msg, wparam, lparam)
	}
	return 0
}

// Función principal
func main() {
	rand.Seed(time.Now().UnixNano())

	// Crear ventana
	hInstance, _ := mylibrary.GetModuleHandle(nil)
	wc := mylibrary.WNDCLASSEX{
		CbSize:        uint32(unsafe.Sizeof(mylibrary.WNDCLASSEX{})),
		LpfnWndProc:   syscall.NewCallback(WndProc),
		HInstance:     hInstance,
		LpszClassName: uintptr(unsafe.Pointer(mylibrary.StringToUTF16Ptr("SnakeGame"))),
		HbrBackground: mylibrary.HBRUSH(mylibrary.COLOR_WINDOW + 1),
	}
	mylibrary.RegisterClassEx(&wc)

	hwnd, _ := mylibrary.CreateWindowEx(
		0,
		uintptr(unsafe.Pointer(mylibrary.StringToUTF16Ptr("SnakeGame"))),
		uintptr(unsafe.Pointer(mylibrary.StringToUTF16Ptr("Snake Game"))),
		mylibrary.WS_OVERLAPPEDWINDOW,
		mylibrary.CW_USEDEFAULT, mylibrary.CW_USEDEFAULT,
		WINDOW_WIDTH, WINDOW_HEIGHT,
		0, 0, hInstance, mylibrary.NULL,
	)

	mylibrary.ShowWindow(hwnd, mylibrary.SW_SHOW)
	mylibrary.UpdateWindow(hwnd)

	// Bucle de mensajes
	var msg mylibrary.MSG
	for mylibrary.GetMessage(&msg, 0, 0, 0) {

		/*if msg.Message == mylibrary.WM_TIMER && updating {
			continue
		}*/

		mylibrary.TranslateMessage(&msg)
		mylibrary.DispatchMessage(&msg)
	}
}
