package main

import (
	"fmt"
	"syscall"
	"time"
	"unsafe"

	mylibrary "github.com/jibaru/gominiwin/windows/primitives"
)

// Constantes para colores
var (
	RED    = mylibrary.RGB(255, 0, 0)
	YELLOW = mylibrary.RGB(255, 255, 0)
	BLUE   = mylibrary.RGB(0, 0, 255)
	WHITE  = mylibrary.RGB(255, 255, 255)
)

// Tamaño de la ventana
const (
	WindowWidth  = 800
	WindowHeight = 600
	SquareSize   = 50
)

// Variables globales
var (
	className = syscall.StringToUTF16Ptr("MyWindowClass")
)

func main() {
	hInstance, err := mylibrary.GetModuleHandle(nil)
	if err != nil {
		panic(err)
	}

	classNamePtr := uintptr(unsafe.Pointer(className))

	// Registrar la clase de la ventana
	wc := mylibrary.WNDCLASSEX{
		CbSize:        uint32(unsafe.Sizeof(mylibrary.WNDCLASSEX{})),
		LpfnWndProc:   syscall.NewCallback(WndProc),
		HInstance:     hInstance,
		LpszClassName: classNamePtr,
		HbrBackground: mylibrary.HBRUSH(mylibrary.COLOR_WINDOW + 1),
	}
	mylibrary.RegisterClassEx(&wc)

	// Crear la ventana
	hwnd, err := mylibrary.CreateWindowEx(
		0,
		classNamePtr,
		uintptr(unsafe.Pointer(mylibrary.StringToUTF16Ptr("Ventana de Dibujo"))),
		mylibrary.WS_OVERLAPPEDWINDOW,
		mylibrary.CW_USEDEFAULT,
		mylibrary.CW_USEDEFAULT,
		WindowWidth,
		WindowHeight,
		0,
		0,
		hInstance,
		mylibrary.NULL, // null
	)
	if err != nil {
		panic(err)
	}

	mylibrary.ShowWindow(hwnd, mylibrary.SW_SHOW)
	mylibrary.UpdateWindow(hwnd)

	// Bucle de mensajes
	var msg mylibrary.MSG
	for mylibrary.GetMessage(&msg, 0, 0, 0) {
		mylibrary.TranslateMessage(&msg)
		mylibrary.DispatchMessage(&msg)
	}
}

func WndProc(hwnd mylibrary.HWND, msg uint32, wparam, lparam uintptr) uintptr {
	switch msg {
	case mylibrary.WM_PAINT:
		Paint(hwnd)
	case mylibrary.WM_KEYDOWN:
		if wparam == 'G' { // Reiniciar el proceso si se presiona "G"
			InvalidateAndRestart(hwnd)
		}
	case mylibrary.WM_DESTROY:
		mylibrary.PostQuitMessage(0)
		return 0
	}
	return mylibrary.DefWindowProc(hwnd, msg, wparam, lparam)
}

func Paint(hwnd mylibrary.HWND) {
	fmt.Println("paint")
	hdc, ps, _ := mylibrary.BeginPaint(hwnd)
	defer mylibrary.EndPaint(hwnd, ps)

	// Dibujar cuadrados
	for y := 0; y < WindowHeight; y += SquareSize {
		for x := 0; x < WindowWidth; x += SquareSize {
			color := RED
			if (x/SquareSize)%2 == 1 {
				color = YELLOW
			}
			brush := mylibrary.CreateSolidBrush(color)
			mylibrary.SelectObject(hdc, brush)
			rect := mylibrary.RECT{Left: int32(x), Top: int32(y), Right: int32(x + SquareSize), Bottom: int32(y + SquareSize)}
			mylibrary.FillRect(hdc, &rect, brush)
			mylibrary.DeleteObject(mylibrary.HGDIOBJ(brush))
			time.Sleep(16 * time.Millisecond) // Esperar 16 ms
		}
	}

	// Esperar 3 segundos
	time.Sleep(3 * time.Second)

	// Dibujar la segunda escena
	mylibrary.FillRect(hdc, &mylibrary.RECT{Left: 0, Top: 0, Right: WindowWidth, Bottom: WindowHeight}, mylibrary.CreateSolidBrush(WHITE))
	DrawCenteredText(hdc, "Hola Mundo")
	mylibrary.MoveToEx(hdc, 0, 0, nil)
	mylibrary.LineTo(hdc, WindowWidth, WindowHeight)

	for x := 0; x < WindowWidth; x += 10 {
		mylibrary.SetPixel(hdc, int32(x), 50, BLUE)
	}

	mylibrary.Ellipse(hdc, 50, 50, 150, 150) // Dibujar círculo
}

func DrawCenteredText(hdc mylibrary.HDC, text string) {
	sz, _ := mylibrary.GetTextExtentPoint32(hdc, text)
	mylibrary.TextOut(hdc, int32((WindowWidth-int(sz.CX))/2), int32((WindowHeight-int(sz.CY))/2), text)
}

func InvalidateAndRestart(hwnd mylibrary.HWND) {
	mylibrary.InvalidateRect(hwnd, nil, true)
	mylibrary.UpdateWindow(hwnd)
}
