package windows

import (
	"fmt"
	"log/slog"
	"sync"
	"syscall"
	"unsafe"
)

const (
	NINGUNA   = -1
	IZQUIERDA = 1
	DERECHA   = 2
	ARRIBA    = 3
	ABAJO     = 4
	ESCAPE    = 5
	ESPACIO   = 6
	RETURN    = 7
	F1        = 8
	F2        = 9
	F3        = 10
	F4        = 11
	F5        = 12
	F6        = 13
	F7        = 14
	F8        = 15
	F9        = 16
	F10       = 17
)

const (
	SRCCOPY             = 0x00CC0020
	CW_USEDEFAULT       = 0x80000000
	WS_OVERLAPPEDWINDOW = 0x00CF0000
	BLACK_BRUSH         = 4
	VK_ESCAPE           = 0x1B
	CS_DBLCLKS          = 0x0008
	WM_DESTROY          = 0x0002
	WM_PAINT            = 0x000F

	WS_VISIBLE = 0x10000000
	SW_SHOW    = 5
	CS_HREDRAW = 0x0002
	CS_VREDRAW = 0x0001
	IDC_ARROW  = 32512

	SWP_NOMOVE = 0x0002
	NULL       = 0
	FALSE      = 0
)

var (
	user32                     = syscall.NewLazyDLL("user32.dll")
	gdi32                      = syscall.NewLazyDLL("gdi32.dll")
	kernel32                   = syscall.NewLazyDLL("kernel32.dll")
	messageBoxW                = user32.NewProc("MessageBoxW")
	invalidateRect             = user32.NewProc("InvalidateRect")
	setWindowPos               = user32.NewProc("SetWindowPos")
	setPixel                   = gdi32.NewProc("SetPixel")
	postMessageW               = user32.NewProc("PostMessageW")
	frameRealProcAddr          = user32.NewProc("AdjustWindowRect")
	procCreateWindowExW        = user32.NewProc("CreateWindowExW")
	procDefWindowProcW         = user32.NewProc("DefWindowProcW")
	procDispatchMessageW       = user32.NewProc("DispatchMessageW")
	procTranslateMessage       = user32.NewProc("TranslateMessage")
	procGetMessageW            = user32.NewProc("GetMessageW")
	procRegisterClassExW       = user32.NewProc("RegisterClassExW")
	procAdjustWindowRect       = user32.NewProc("AdjustWindowRect")
	procPostQuitMessage        = user32.NewProc("PostQuitMessage")
	procShowWindow             = user32.NewProc("ShowWindow")
	procBeginPaint             = user32.NewProc("BeginPaint")
	procEndPaint               = user32.NewProc("EndPaint")
	procGetDC                  = gdi32.NewProc("GetDC")
	procCreateCompatibleDC     = gdi32.NewProc("CreateCompatibleDC")
	procCreateCompatibleBitmap = gdi32.NewProc("CreateCompatibleBitmap")
	procSelectObject           = gdi32.NewProc("SelectObject")
	procBitBlt                 = gdi32.NewProc("BitBlt")
	procDeleteObject           = gdi32.NewProc("DeleteObject")
	procDeleteDC               = gdi32.NewProc("DeleteDC")
)

type (
	WndProc func(hwnd uintptr, msg uint32, wParam, lParam uintptr) uintptr

	WNDCLASSEX struct {
		Size       uint32
		Style      uint32
		WndProc    uintptr
		ClsExtra   int32
		WndExtra   int32
		Instance   uintptr
		Icon       uintptr
		Cursor     uintptr
		Background uintptr
		MenuName   *uint16
		ClassName  *uint16
		IconSm     uintptr
	}

	MSG struct {
		Hwnd    uintptr
		Message uint32
		WParam  uintptr
		LParam  uintptr
		Time    uint32
		Pt      POINT
	}

	POINT struct {
		X, Y int32
	}

	PAINTSTRUCT struct {
		Hdc        uintptr
		FErase     int32
		RcPaint    RECT
		FRestore   int32
		FIncUpdate int32
		Reserved   [32]byte
	}

	RECT struct {
		Left, Top, Right, Bottom int32
	}
)

type Window struct {
	Mutex       sync.Mutex
	Instance    uintptr
	HWnd        uintptr
	Bitmap      uintptr
	MemDC       uintptr
	Width       int
	Height      int
	Teclas      []int
	MouseInside bool
	MouseX      float32
	MouseY      float32
	LeftButton  bool
	RightButton bool
	Color       uint32
	ClassName   string
}

func (w *Window) Tecla() int {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	if len(w.Teclas) == 0 {
		return NINGUNA
	}

	key := w.Teclas[0]
	w.Teclas = w.Teclas[1:]

	switch key {
	case 0x25:
		return IZQUIERDA
	case 0x27:
		return DERECHA
	case 0x26:
		return ARRIBA
	case 0x28:
		return ABAJO
	case 0x1B:
		return ESCAPE
	case 0x20:
		return ESPACIO
	case 0x0D:
		return RETURN
	case 0x70:
		return F1
	case 0x71:
		return F2
	case 0x72:
		return F3
	case 0x73:
		return F4
	case 0x74:
		return F5
	case 0x75:
		return F6
	case 0x76:
		return F7
	case 0x77:
		return F8
	case 0x78:
		return F9
	case 0x79:
		return F10
	default:
		return key
	}
}

func (w *Window) Raton(x, y *float32) bool {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	if !w.MouseInside {
		return false
	}

	*x = w.MouseX
	*y = w.MouseY
	return true
}

func (w *Window) RatonDentro() bool {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	return w.MouseInside
}

func (w *Window) RatonX() float32 {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	return w.MouseX
}

func (w *Window) RatonY() float32 {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	return w.MouseY
}

func (w *Window) RatonBotones(izq, der *bool) {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	*izq = w.LeftButton
	*der = w.RightButton
}

func (w *Window) RatonBotonIzq() bool {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	return w.LeftButton
}

func (w *Window) RatonBotonDer() bool {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	return w.RightButton
}

func (w *Window) Espera(miliseg int) {
	kernel32.NewProc("Sleep").Call(uintptr(miliseg))
}

func (w *Window) Mensaje(msj string) {
	a, _ := syscall.UTF16PtrFromString(msj)
	b, _ := syscall.UTF16PtrFromString("Mensaje...")

	messageBoxW.Call(
		w.HWnd,
		uintptr(unsafe.Pointer(a)),
		uintptr(unsafe.Pointer(b)),
		0,
	)
}

func (w *Window) Pregunta(msj string) bool {
	a, _ := syscall.UTF16PtrFromString(msj)
	b, _ := syscall.UTF16PtrFromString("Pregunta...")

	ret, _, _ := messageBoxW.Call(
		w.HWnd,
		uintptr(unsafe.Pointer(a)),
		uintptr(unsafe.Pointer(b)),
		1,
	)
	return ret == 1
}

func (w *Window) Borra() {
	w.Mutex.Lock()
	defer w.Mutex.Unlock()

	rect := struct {
		left, top, right, bottom int32
	}{0, 0, int32(w.Width), int32(w.Height)}

	brush, _, _ := gdi32.NewProc("CreateSolidBrush").Call(0)
	gdi32.NewProc("FillRect").Call(w.MemDC, uintptr(unsafe.Pointer(&rect)), brush)
	gdi32.NewProc("DeleteObject").Call(brush)
}

func (w *Window) Refresca() {
	invalidateRect.Call(w.HWnd, 0, 0)
}

func (w *Window) Punto(x, y float32) {
	setPixel.Call(w.MemDC, uintptr(int32(x)), uintptr(int32(y)), uintptr(w.Color))
}

func (w *Window) SetColor(c int) {
	colors := []uint32{
		0x000000, // NEGRO
		0xFF0000, // ROJO
		0x00FF00, // VERDE
		0x0000FF, // AZUL
		0xFFFF00, // AMARILLO
		0xFF00FF, // MAGENTA
		0x00FFFF, // CYAN
		0xFFFFFF, // BLANCO
	}

	if c >= 0 && c < len(colors) {
		w.Color = colors[c]
	} else {
		w.Color = colors[0] // Default to black
	}
}

func (w *Window) VCierra() {
	postMessageW.Call(w.HWnd, 0x0010, 0, 0) // WM_CLOSE
}

func (w *Window) vredimensiona(width, height int) {
	w.Width = width
	w.Height = height
	var ww, hh int32
	frame_real(w.Width, w.Height, &ww, &hh)
	setWindowPos.Call(w.HWnd, NULL, 0, 0, uintptr(ww), uintptr(hh), SWP_NOMOVE)
	w.newMemDC(ww, hh)
}

func (w *Window) newMemDC(w, h int32) {
	if w.MemDC != NULL {
		procDeleteObject.Call(win.Bitmap)
		procDeleteDC.Call(win.MemDC)
	}

	procGetDC.Call()

	hDC, _, _ := procGetDC.Call(w.HWnd)
	hDCMem, _, _ := procCreateCompatibleDC.Call(hDC)
	hBitmap, _, _ := procCreateCompatibleBitmap.Call(hDC, w, h)
	procSelectObject.Call(hDCMem, hBitmap)
	procSetBkMode.Call(hDCMem, TRANSPARENT)
}

func frame_real(w, h int, rw, rh *int32) {
	frame := RECT{0, 0, int32(w), int32(h)}
	procAdjustWindowRect.Call(uintptr(unsafe.Pointer(&frame)), WS_OVERLAPPEDWINDOW, FALSE)
	v1 := frame.Right - frame.Left
	v2 := frame.Bottom - frame.Top

	rw = &v1
	rh = &v2
}

func (win *Window) Initialize(className string, title string, width, height int32) error {
	win.Width = int(width)
	win.Height = int(height)
	win.ClassName = className

	classNamePtr, _ := syscall.UTF16PtrFromString(className)

	// Register the window class
	var wc WNDCLASSEX
	wc.Size = uint32(unsafe.Sizeof(wc))
	wc.Style = CS_DBLCLKS
	wc.WndProc = syscall.NewCallback(win.WndProc)
	wc.Instance = win.Instance
	wc.Background = BLACK_BRUSH
	wc.ClassName = classNamePtr

	if _, _, err := procRegisterClassExW.Call(uintptr(unsafe.Pointer(&wc))); err != nil && err != syscall.Errno(0) {
		return fmt.Errorf("failed to register window class: %w", err)
	}

	// Adjust window size
	var rect RECT
	rect.Right = width
	rect.Bottom = height
	procAdjustWindowRect.Call(uintptr(unsafe.Pointer(&rect)), WS_OVERLAPPEDWINDOW, 0)

	win.Width = int(rect.Right - rect.Left)
	win.Height = int(rect.Bottom - rect.Top)

	// Create the window
	hwnd, _, err := procCreateWindowExW.Call(
		0,
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(className))),
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(title))),
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT,
		uintptr(win.Width), uintptr(win.Height),
		0, 0, win.Instance, 0,
	)
	if hwnd == 0 {
		return fmt.Errorf("failed to create window: %w", err)
	}
	win.HWnd = hwnd

	return nil
}

func (win *Window) Run() {
	// Show the window
	procShowWindow.Call(win.HWnd, 1)

	var msg MSG
	for {
		ret, _, _ := procGetMessageW.Call(uintptr(unsafe.Pointer(&msg)), 0, 0, 0)
		if ret == 0 {
			break
		}
		procTranslateMessage.Call(uintptr(unsafe.Pointer(&msg)))
		procDispatchMessageW.Call(uintptr(unsafe.Pointer(&msg)))
	}
}

func (win *Window) Cleanup() {
	if win.Bitmap != 0 {
		procDeleteObject.Call(win.Bitmap)
	}
	if win.MemDC != 0 {
		procDeleteDC.Call(win.MemDC)
	}
}

func (win *Window) WndProc(hwnd uintptr, msg uint32, wParam, lParam uintptr) uintptr {
	slog.Info("message arrived", "msg", msg)

	switch msg {
	case WM_DESTROY:
		procPostQuitMessage.Call(0)
		return 0
	case WM_PAINT:
		var ps PAINTSTRUCT
		hdc, _, _ := procBeginPaint.Call(hwnd, uintptr(unsafe.Pointer(&ps)))
		if win.Bitmap != 0 {
			procSelectObject.Call(win.MemDC, win.Bitmap)
			procBitBlt.Call(hdc, 0, 0, uintptr(win.Width), uintptr(win.Height), win.MemDC, 0, 0, SRCCOPY)
		}
		procEndPaint.Call(hwnd, uintptr(unsafe.Pointer(&ps)))
		return 0
	default:
		ret, _, _ := procDefWindowProcW.Call(hwnd, uintptr(msg), wParam, lParam)
		return ret
	}
}
