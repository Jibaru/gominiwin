package windows

import (
	"container/list"
	"fmt"
	"log/slog"
	"syscall"
	"unsafe"
)

// Importar DLLs de Windows
var (
	user32   = syscall.NewLazyDLL("user32.dll")
	gdi32    = syscall.NewLazyDLL("gdi32.dll")
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	// Funciones de las DLLs
	registerClassEx      = user32.NewProc("RegisterClassExW")
	procAdjustWindowRect = user32.NewProc("AdjustWindowRect")
	procCreateWindowExW  = user32.NewProc("CreateWindowExW")
	defWindowProcW       = user32.NewProc("DefWindowProcW")

	procDispatchMessageW = user32.NewProc("DispatchMessageW")
	procTranslateMessage = user32.NewProc("TranslateMessage")
	procGetMessageW      = user32.NewProc("GetMessageW")

	loadCursorW                = user32.NewProc("LoadCursorW")
	registerClassExW           = user32.NewProc("RegisterClassExW")
	procShowWindow             = user32.NewProc("ShowWindow")
	updateWindow               = user32.NewProc("UpdateWindow")
	invalidateRect             = user32.NewProc("InvalidateRect")
	messageBoxW                = user32.NewProc("MessageBoxW")
	postQuitMessage            = user32.NewProc("PostQuitMessage")
	beginPaintProc             = user32.NewProc("BeginPaint")
	endPaintProc               = user32.NewProc("EndPaint")
	moveToExProc               = gdi32.NewProc("MoveToEx")
	lineToProc                 = gdi32.NewProc("LineTo")
	getStockObjectProc         = gdi32.NewProc("GetStockObject")
	fillRectProc               = user32.NewProc("FillRect")
	getDCProc                  = user32.NewProc("GetDC")
	releaseDCProc              = user32.NewProc("ReleaseDC")
	bitBltProc                 = gdi32.NewProc("BitBlt")
	deleteObjectProc           = gdi32.NewProc("DeleteObject")
	deleteDCProc               = gdi32.NewProc("DeleteDC")
	createCompatibleBitmapProc = gdi32.NewProc("CreateCompatibleBitmap")
	createCompatibleDCProc     = gdi32.NewProc("CreateCompatibleDC")
	selectObjectProc           = gdi32.NewProc("SelectObject")
)

// Variables globales
var (
	Instance       syscall.Handle
	hWnd           syscall.Handle // Ventana principal
	hBitmap        syscall.Handle // Bitmap para pintar off-screen
	iWidth         = 400          // Ancho de la ventana
	iHeight        = 300          // Alto de la ventana
	hDCMem         syscall.Handle // Device Context en memoria
	teclasQueue    = list.New()   // Cola de teclas
	ratonDentro    bool           // ¿Ratón está dentro del área cliente?
	xRaton, yRaton int            // Posición del ratón
	botIzq, botDer bool           // Botones izquierdo y derecho
)

// Constantes necesarias
const (
	NULL  = 0
	FALSE = 0
	TRUE  = 1

	CS_VREDRAW          = 0x0001
	CS_HREDRAW          = 0x0002
	WS_OVERLAPPEDWINDOW = 0x00CF0000
	SW_SHOW             = 5
	CS_DBLCLKS          = 0x0008
	BLACK_BRUSH         = 4

	CW_USEDEFAULT = 0x80000000
	VK_ESCAPE     = 0x1B
	WM_DESTROY    = 0x0002
	WM_PAINT      = 0x000F

	WS_VISIBLE = 0x10000000

	SWP_NOMOVE = 0x0002

	IDC_ARROW = 32512

	WHITE_BRUSH = 0
	SRCCOPY     = 0x00CC0020
)

// Tipo para el procedimiento de ventana
type WndProc func(hWnd syscall.Handle, msg uint32, wParam, lParam uintptr) uintptr

type WNDCLASSEX struct {
	Size       uint32
	Style      uint32
	WndProc    uintptr
	ClsExtra   int32
	WndExtra   int32
	Instance   uintptr
	Icon       uintptr
	Cursor     uintptr
	Background uintptr
	ClassName  *uint16
	IconSm     uintptr
}

type MSG struct {
	HWnd    syscall.Handle
	Message uint32
	WParam  uintptr
	LParam  uintptr
	Time    uint32
	Pt      POINT
}

type POINT struct {
	X, Y int32
}

type PAINTSTRUCT struct {
	Hdc         syscall.Handle
	FErase      int32
	Rect        Rect
	Restore     int32
	IncUpdate   int32
	RGBReserved [32]byte
}

type Rect struct {
	Left, Top, Right, Bottom int32
}

func frameReal(w, h int, rw, rh *int) {
	var rect Rect
	rect.Left = 0
	rect.Top = 0
	rect.Right = int32(w)
	rect.Bottom = int32(h)

	// Estilo de ventana predeterminado
	const WS_OVERLAPPEDWINDOW = 0x00CF0000

	// Llamar a AdjustWindowRect para calcular los bordes
	user32 := syscall.NewLazyDLL("user32.dll")
	adjustWindowRect := user32.NewProc("AdjustWindowRect")

	ret, _, _ := adjustWindowRect.Call(
		uintptr(unsafe.Pointer(&rect)),
		WS_OVERLAPPEDWINDOW,
		0, // FALSE, sin menú
	)
	if ret == 0 {
		panic("Failed to adjust window rect")
	}

	*rw = int(rect.Right - rect.Left)
	*rh = int(rect.Bottom - rect.Top)
}

func newMemDC(w, h int) {
	// Obtener el DC de la pantalla
	user32 := syscall.NewLazyDLL("user32.dll")
	gdi32 := syscall.NewLazyDLL("gdi32.dll")

	getDC := user32.NewProc("GetDC")
	releaseDC := user32.NewProc("ReleaseDC")
	createCompatibleDC := gdi32.NewProc("CreateCompatibleDC")
	createCompatibleBitmap := gdi32.NewProc("CreateCompatibleBitmap")
	selectObject := gdi32.NewProc("SelectObject")
	deleteObject := gdi32.NewProc("DeleteObject")
	deleteDC := gdi32.NewProc("DeleteDC")

	screenDC, _, _ := getDC.Call(0)
	if screenDC == 0 {
		panic("Failed to get screen DC")
	}
	defer releaseDC.Call(0, screenDC)

	// Crear un DC compatible en memoria
	memDC, _, _ := createCompatibleDC.Call(screenDC)
	if memDC == 0 {
		panic("Failed to create compatible DC")
	}

	// Crear un bitmap compatible
	bitmap, _, _ := createCompatibleBitmap.Call(screenDC, uintptr(w), uintptr(h))
	if bitmap == 0 {
		deleteDC.Call(memDC)
		panic("Failed to create compatible bitmap")
	}

	// Seleccionar el bitmap en el DC de memoria
	oldBitmap, _, _ := selectObject.Call(memDC, bitmap)
	if oldBitmap == 0 {
		deleteObject.Call(bitmap)
		deleteDC.Call(memDC)
		panic("Failed to select bitmap into memory DC")
	}

	// Almacenar el DC en la variable global
	hDCMem = syscall.Handle(memDC)
}

func WindowProcedure(hWnd syscall.Handle, message uint32, wParam, lParam uintptr) uintptr {
	slog.Info("called", "msg", message)

	switch message {
	case 0x0010: // WM_CLOSE
		user32 := syscall.NewLazyDLL("user32.dll")
		postQuitMessage := user32.NewProc("PostQuitMessage")
		postQuitMessage.Call(0)
		return 0

	case 0x000F: // WM_PAINT
		hdc, ps := beginPaint(hWnd)
		selectObject(hdc, hBitmap)
		if hBitmap != NULL {
			bitBlt(hdc, 0, 0, iWidth, iHeight, hDCMem, 0, 0, SRCCOPY)
		}
		endPaint(hWnd, ps)
		return 0

	case 0x0200: // WM_MOUSEMOVE
		// Manejar el movimiento del ratón
		return 0

	case 0x0201: // WM_LBUTTONDOWN
		// Manejar el botón izquierdo del ratón
		return 0

	case 0x0202: // WM_LBUTTONUP
		// Manejar la liberación del botón izquierdo del ratón
		return 0

	case 0x0204: // WM_RBUTTONDOWN
		// Manejar el botón derecho del ratón
		return 0

	case 0x0205: // WM_RBUTTONUP
		// Manejar la liberación del botón derecho del ratón
		return 0

	default:
		user32 := syscall.NewLazyDLL("user32.dll")
		defWindowProc := user32.NewProc("DefWindowProcW")
		result, _, _ := defWindowProc.Call(
			uintptr(hWnd),
			uintptr(message),
			wParam,
			lParam,
		)
		return result
	}
}

func beginPaint(hWnd syscall.Handle) (syscall.Handle, *PAINTSTRUCT) {
	var ps PAINTSTRUCT
	ret, _, _ := beginPaintProc.Call(uintptr(hWnd), uintptr(unsafe.Pointer(&ps)))
	return syscall.Handle(ret), &ps
}

func endPaint(hWnd syscall.Handle, ps *PAINTSTRUCT) {
	endPaintProc.Call(uintptr(hWnd), uintptr(unsafe.Pointer(ps)))
}

func moveToEx(hdc syscall.Handle, x, y int32, lpPoint *POINT) {
	moveToExProc.Call(uintptr(hdc), uintptr(x), uintptr(y), uintptr(unsafe.Pointer(lpPoint)))
}

func lineTo(hdc syscall.Handle, x, y int32) {
	lineToProc.Call(uintptr(hdc), uintptr(x), uintptr(y))
}

func WinMain(width, height int, title string) error {
	/*user32 := syscall.NewLazyDLL("user32.dll")

	// Obtener procedimientos necesarios
	registerClassEx := user32.NewProc("RegisterClassExW")
	createWindowEx := user32.NewProc("CreateWindowExW")
	showWindow := user32.NewProc("ShowWindow")
	updateWindow := user32.NewProc("UpdateWindow")
	getMessage := user32.NewProc("GetMessageW")
	translateMessage := user32.NewProc("TranslateMessage")
	dispatchMessage := user32.NewProc("DispatchMessageW")

	// Definir la clase de ventana
	var wc WNDCLASSEX
	wc.Size = uint32(unsafe.Sizeof(wc))
	wc.Style = 0x0003 // CS_HREDRAW | CS_VREDRAW
	wc.WndProc = syscall.NewCallback(WindowProcedure)
	wc.Background = 5 // COLOR_WINDOW + 1
	wc.ClassName = syscall.StringToUTF16Ptr("MiniWin")

	ret, _, _ := registerClassEx.Call(uintptr(unsafe.Pointer(&wc)))
	if ret == 0 {
		panic("Failed to register window class")
	}

	// Crear la ventana principal
	hWnd, _, _ := createWindowEx.Call(
		0, // dwExStyle
		uintptr(unsafe.Pointer(wc.ClassName)),
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr("Mini Window"))),
		0x10CF0000, // WS_OVERLAPPEDWINDOW
		100, 100,   // x, y
		400, 300, // width, height
		0, 0, // hWndParent, hMenu
		uintptr(wc.Instance),
		0,
	)
	if hWnd == 0 {
		panic("Failed to create window")
	}

	// Mostrar y actualizar la ventana
	showWindow.Call(hWnd, 1)
	updateWindow.Call(hWnd)

	// Bucle de mensajes
	var msg MSG
	for {
		ret, _, _ := getMessage.Call(uintptr(unsafe.Pointer(&msg)), 0, 0, 0)
		if ret == 0 {
			break
		}

		translateMessage.Call(uintptr(unsafe.Pointer(&msg)))
		dispatchMessage.Call(uintptr(unsafe.Pointer(&msg)))
	}

	return int(msg.WParam)*/

	iWidth = int(width)
	iHeight = int(height)
	className := "Miniwin"

	classNamePtr, err := syscall.UTF16PtrFromString(className)
	if err != nil {
		return fmt.Errorf("failed to create classname: %w", err)
	}

	// Register the window class
	var wc WNDCLASSEX
	wc.Size = uint32(unsafe.Sizeof(wc))
	wc.Style = CS_DBLCLKS
	wc.WndProc = syscall.NewCallback(WindowProcedure)
	wc.Instance = NULL
	wc.Background = BLACK_BRUSH
	wc.ClassName = classNamePtr
	wc.Instance = uintptr(Instance)

	if _, _, err := registerClassEx.Call(uintptr(unsafe.Pointer(&wc))); err != nil && err != syscall.Errno(0) {
		return fmt.Errorf("failed to register window class: %w", err)
	}

	// Adjust window size
	var rect Rect
	rect.Right = int32(width)
	rect.Bottom = int32(height)
	procAdjustWindowRect.Call(uintptr(unsafe.Pointer(&rect)), WS_OVERLAPPEDWINDOW, 0)

	iWidth = int(rect.Right - rect.Left)
	iHeight = int(rect.Bottom - rect.Top)

	// Create the window
	hwnd, _, err := procCreateWindowExW.Call(
		0,
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(className))),
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(title))),
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT,
		uintptr(width), uintptr(height),
		0, 0, uintptr(Instance), 0,
	)
	if hwnd == 0 {
		return fmt.Errorf("failed to create window: %w", err)
	}
	hWnd = syscall.Handle(hwnd)

	return nil
}

func Run() {
	// Show the window
	procShowWindow.Call(uintptr(hWnd), 1)

	var msg MSG
	for {
		ret, _, _ := procGetMessageW.Call(uintptr(unsafe.Pointer(&msg)), 0, 0, 0)
		if ret == 0 {
			break
		}
		procTranslateMessage.Call(uintptr(unsafe.Pointer(&msg)))
		procDispatchMessageW.Call(uintptr(unsafe.Pointer(&msg)))
	}
}

func Borra() {
	if hDCMem != 0 {
		brush := syscall.Handle(getStockObject(0)) // WHITE_BRUSH
		rect := Rect{0, 0, int32(iWidth), int32(iHeight)}
		fillRect(syscall.Handle(hDCMem), &rect, brush)
	}
}

func fillRect(hdc syscall.Handle, rect *Rect, hBrush syscall.Handle) {
	fillRectProc.Call(uintptr(hdc), uintptr(unsafe.Pointer(rect)), uintptr(hBrush))
}

func getStockObject(index int) syscall.Handle {
	ret, _, _ := getStockObjectProc.Call(uintptr(index))
	return syscall.Handle(ret)
}

func Refresca() {
	hdc := getDC(hWnd)
	defer releaseDC(hWnd, hdc)

	bitBlt(hdc, 0, 0, iWidth, iHeight, syscall.Handle(hDCMem), 0, 0, 0x00CC0020) // SRCCOPY
}

func getDC(hWnd syscall.Handle) syscall.Handle {
	ret, _, _ := getDCProc.Call(uintptr(hWnd))
	return syscall.Handle(ret)
}

func releaseDC(hWnd syscall.Handle, hdc syscall.Handle) {
	releaseDCProc.Call(uintptr(hWnd), uintptr(hdc))
}

func bitBlt(hdcDest syscall.Handle, xDest, yDest, width, height int, hdcSrc syscall.Handle, xSrc, ySrc, rop int) {
	bitBltProc.Call(uintptr(hdcDest), uintptr(xDest), uintptr(yDest), uintptr(width), uintptr(height), uintptr(hdcSrc), uintptr(xSrc), uintptr(ySrc), uintptr(rop))
}

func deleteObject(hObject syscall.Handle) {
	deleteObjectProc.Call(uintptr(hObject))
}

func deleteDC(hDC syscall.Handle) {
	deleteDCProc.Call(uintptr(hDC))
}

func createCompatibleBitmap(hdc syscall.Handle, width, height int) syscall.Handle {
	ret, _, _ := createCompatibleBitmapProc.Call(uintptr(hdc), uintptr(width), uintptr(height))
	return syscall.Handle(ret)
}

func createCompatibleDC(hdc syscall.Handle) syscall.Handle {
	ret, _, _ := createCompatibleDCProc.Call(uintptr(hdc))
	return syscall.Handle(ret)
}

func selectObject(hdc syscall.Handle, hObject syscall.Handle) syscall.Handle {
	ret, _, _ := selectObjectProc.Call(uintptr(hdc), uintptr(hObject))
	return syscall.Handle(ret)
}

func vredimensiona(ample, alt int) {
	if ample != iWidth || alt != iHeight {
		if hBitmap != 0 {
			deleteObject(syscall.Handle(hBitmap))
		}

		if hDCMem != 0 {
			deleteDC(syscall.Handle(hDCMem))
		}

		iWidth, iHeight = ample, alt
		hBitmap = createCompatibleBitmap(getDC(hWnd), ample, alt)
		hDCMem = syscall.Handle(createCompatibleDC(getDC(hWnd)))
		selectObject(syscall.Handle(hDCMem), syscall.Handle(hBitmap))
	}
}

func linea(x_ini, y_ini, x_fin, y_fin float64) {
	if hDCMem != 0 {
		moveToEx(syscall.Handle(hDCMem), int32(x_ini), int32(y_ini), nil)
		lineTo(syscall.Handle(hDCMem), int32(x_fin), int32(y_fin))
	}
}
