package main

import (
	"fmt"
	"syscall"
	"time"
	"unsafe"

	mylibrary "github.com/jibaru/gominiwin/windows"
)

// Constantes para colores
var (
	RED    = mylibrary.RGB(255, 0, 0)
	YELLOW = mylibrary.RGB(255, 255, 0)
	BLUE   = mylibrary.RGB(0, 0, 255)
	WHITE  = mylibrary.RGB(255, 255, 255)
)

// Tamaño de la ventana
const (
	WindowWidth  = 800
	WindowHeight = 600
	SquareSize   = 50
)

// Variables globales
var (
	className    = syscall.StringToUTF16Ptr("MyWindowClass")
	stepX, stepY int
	scene        = 1
	isRestarting = false
)

func main() {
	hInstance, err := mylibrary.GetModuleHandle(nil)
	if err != nil {
		panic(err)
	}

	classNamePtr := uintptr(unsafe.Pointer(className))

	// Registrar la clase de la ventana
	wc := mylibrary.WNDCLASSEX{
		CbSize:        uint32(unsafe.Sizeof(mylibrary.WNDCLASSEX{})),
		LpfnWndProc:   syscall.NewCallback(WndProc),
		HInstance:     hInstance,
		LpszClassName: classNamePtr,
		HbrBackground: mylibrary.HBRUSH(mylibrary.COLOR_WINDOW + 1),
	}
	mylibrary.RegisterClassEx(&wc)

	// Crear la ventana
	hwnd, err := mylibrary.CreateWindowEx(
		0,
		classNamePtr,
		uintptr(unsafe.Pointer(mylibrary.StringToUTF16Ptr("Ventana de Dibujo"))),
		mylibrary.WS_OVERLAPPEDWINDOW,
		mylibrary.CW_USEDEFAULT,
		mylibrary.CW_USEDEFAULT,
		WindowWidth,
		WindowHeight,
		0,
		0,
		hInstance,
		mylibrary.NULL,
	)
	if err != nil {
		panic(err)
	}

	mylibrary.ShowWindow(hwnd, mylibrary.SW_SHOW)
	mylibrary.UpdateWindow(hwnd)

	// Crear un temporizador para manejar el ciclo de dibujo
	mylibrary.SetTimer(hwnd, 1, 16, 0)

	// Bucle de mensajes
	var msg mylibrary.MSG
	for mylibrary.GetMessage(&msg, 0, 0, 0) {
		mylibrary.TranslateMessage(&msg)
		mylibrary.DispatchMessage(&msg)
	}
}

func WndProc(hwnd mylibrary.HWND, msg uint32, wparam, lparam uintptr) uintptr {
	switch msg {
	case mylibrary.WM_TIMER:
		Update(hwnd)
	case mylibrary.WM_PAINT:
		Paint(hwnd)
	case mylibrary.WM_KEYDOWN:
		if wparam == 'G' { // Reiniciar el proceso si se presiona "G"
			isRestarting = true
			stepX, stepY = 0, 0
			scene = 1
			mylibrary.InvalidateRect(hwnd, nil, true)
		}
	case mylibrary.WM_DESTROY:
		mylibrary.PostQuitMessage(0)
		return 0
	}
	return mylibrary.DefWindowProc(hwnd, msg, wparam, lparam)
}

func Update(hwnd mylibrary.HWND) {
	fmt.Println("Update")
	if scene == 1 {
		// Avanzar al siguiente cuadrado
		stepX += SquareSize
		if stepX >= WindowWidth {
			stepX = 0
			stepY += SquareSize
			if stepY >= WindowHeight {
				// Cambiar a la siguiente escena después de llenar la ventana
				scene = 2
				stepX, stepY = 0, 0
				go func() {
					time.Sleep(3 * time.Second)
					mylibrary.InvalidateRect(hwnd, nil, true)
				}()
			}
		}
	} else if isRestarting {
		isRestarting = false
		mylibrary.InvalidateRect(hwnd, nil, true)
	}
	mylibrary.InvalidateRect(hwnd, nil, false)
}

func Paint(hwnd mylibrary.HWND) {
	fmt.Println("Paint")
	hdc, ps, _ := mylibrary.BeginPaint(hwnd)
	defer mylibrary.EndPaint(hwnd, ps)

	if scene == 1 {
		// Dibujar cuadrados
		for y := 0; y <= stepY; y += SquareSize {
			for x := 0; x < WindowWidth; x += SquareSize {
				if y == stepY && x >= stepX {
					break
				}
				color := RED
				if (x/SquareSize)%2 == 1 {
					color = YELLOW
				}
				brush := mylibrary.CreateSolidBrush(color)
				mylibrary.SelectObject(hdc, brush)
				rect := mylibrary.RECT{Left: int32(x), Top: int32(y), Right: int32(x + SquareSize), Bottom: int32(y + SquareSize)}
				mylibrary.FillRect(hdc, &rect, brush)
				mylibrary.DeleteObject(mylibrary.HGDIOBJ(brush))
			}
		}
	} else if scene == 2 {
		// Escena 2: Dibujar fondo blanco y otros elementos
		mylibrary.FillRect(hdc, &mylibrary.RECT{Left: 0, Top: 0, Right: WindowWidth, Bottom: WindowHeight}, mylibrary.CreateSolidBrush(WHITE))
		DrawCenteredText(hdc, "Hola Mundo")
		mylibrary.MoveToEx(hdc, 0, 0, nil)
		mylibrary.LineTo(hdc, WindowWidth, WindowHeight)

		for x := 0; x < WindowWidth; x += 10 {
			mylibrary.SetPixel(hdc, int32(x), 50, BLUE)
		}

		mylibrary.Ellipse(hdc, 50, 50, 150, 150) // Dibujar círculo
	}
}

func DrawCenteredText(hdc mylibrary.HDC, text string) {
	sz, _ := mylibrary.GetTextExtentPoint32(hdc, text)
	mylibrary.TextOut(hdc, int32((WindowWidth-int(sz.CX))/2), int32((WindowHeight-int(sz.CY))/2), text)
}
